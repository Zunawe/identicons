/* MIT License
 * 
 * Copyright (c) 2018 Bryce Wilson
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * A function that returns a hash generated by an input string (such as MD5 or SHA-1).
 * 
 * @callback hashFunction
 * @param {string} id - A string id to be represented by an identicon.
 * @returns {string} A string representation of a hexadecimal number. The length of this string must be even.
 */

 /**
  * Creates an identicon generator. One instance can generate any type of
  * identicon, but you may change the default options per instance.
  * 
  * @constructor
  * @param {hashFunction} hashFunction - The function to be used for hashing ids.
  * @param {Object} userOptions - Default options to use when generating identicons.
  */
 function IdenticonGenerator(hashFunction, userOptions){
	var _this = this;

	_this.defaultOptions = {
		type: 'square',
		size: 512,
		shells: 4,
		segments: Infinity,
		symmetryAxisTilt: null,
		edges: 5
	};
	_this.defaultOptions = fillDefaultOptions(userOptions);

	/**
	 * Sets all options not set by the user to this object's defaults.
	 * 
	 * @private
	 * @param {Object} userOptions - The options the user provides.
	 */
	function fillDefaultOptions(userOptions){
		if(userOptions === undefined){
			return _this.defaultOptions;
		}

		options = {};
		for(option in _this.defaultOptions){
			options[option] = userOptions[option] === undefined ? _this.defaultOptions[option] : userOptions[option];
		}
		return options;
	}

	_this.hashFunction = hashFunction;

	var svgNS = 'http://www.w3.org/2000/svg';
	var generatorFunctions = {
		square: generateSquare,
		circular: generateCircular,
		polygonal: generatePolygonal
	};

	/**
	 * Generates an identicon from an id and configuration.
	 * 
	 * @param {string} id - A string id to be represented by an identicon.
	 * @param {Object} [options] - Settings to change the shape and size of the identicon (not all options have an effect on certain shapes).
	 * @param {string} [options.type='square'] - The type of identicon to generate ('square', 'circular', or 'polygonal').
	 * @param {number} [options.size=512] - The dimension of the image in pixels.
	 * @param {number} [options.shells=4] - The number of shells to generate.
	 * @param {number} [options.segments=Infinity] - The number of segments of equal angle to snap the arcs to.
	 * @param {number} [options.symmetryAxisTilt=null] - If a number, makes the SVG symmetric about the line defined here in polar coordinates (degrees).
	 * @param {number} [options.edges=5] - The number of edges (i.e. 6 makes a regular hexagon shape).
	 * @returns {Object} SVG element object containing the identicon.
	 */
	_this.generate = function (id, options){
		return generatorFunctions[options.type](_this.hashFunction(id), fillDefaultOptions(options));
	}

	/**
	 * Turns an id and a hashing function into a unique square identicon SVG element.
	 * 
	 * @private
	 * @param {string} hash - A string representation of a hexadecimal number. The length of this string must be even.
	 * @param {Object} [options] - Settings to change the shape and size of the identicon (not all options have an effect on certain shapes).
	 * @param {number} [options.size=512] - The dimension of the image in pixels.
	 * @returns {Object} SVG element object containing the identicon.
	 */
	function generateSquare(hash, options){
		var bytes = string2ByteArray(hash);

		var svg = document.createElementNS(svgNS, 'svg');
		var size = options.size;

		// crispEdges prevents seams between blocks (we know everything is 90 degree angles anyway)
		svg.setAttribute('width', size);
		svg.setAttribute('height', size);
		svg.setAttribute('xmlns', svgNS);
		svg.setAttribute('shape-rendering', 'crispEdges');

		// Inner loop stops at 3 for symmetry
		var pixelMap = [[], [], [], [], []];
		for(var i = 0; i < 5; ++i){
			for(var j = 0; j < 3; ++j){
				pixelMap[i][j] = !!getBit((i * 3) + j, bytes);
			}
			pixelMap[i][3] = pixelMap[i][1];
			pixelMap[i][4] = pixelMap[i][0];
		}

		var fillColor = '#' + padFront(bytes[bytes.length - 3], 16, 2) +
		                      padFront(bytes[bytes.length - 2], 16, 2) +
		                      padFront(bytes[bytes.length - 1], 16, 2);
		var boxSize = Math.floor(size / 6);
		var marginSize = Math.floor((boxSize / 2) + ((size % 6) / 2));

		for(var i = 0; i < 5; ++i){
			for(var j = 0; j < 5; ++j){
				if(pixelMap[i][j]){
					var rect = document.createElementNS(svgNS, 'rect');

					rect.setAttribute('x', marginSize + (j * boxSize));
					rect.setAttribute('y', marginSize + (i * boxSize));
					rect.setAttribute('width', boxSize);
					rect.setAttribute('height', boxSize);
					rect.setAttribute('fill', fillColor);

					svg.appendChild(rect);
				}
			}
		}

		return svg;
	}

	/**
	 * Turns an id and a hashing function into a unique circular identicon SVG element.
	 * 
	 * @private
	 * @param {string} hash - A string representing a hexadecimal number. Ideally, this is the output of a hash function such as MD5 or SHA-1.
	 * @param {Object} [options] - Settings to change the shape and size of the identicon (not all options have an effect on certain shapes).
	 * @param {number} [options.size=512] - The dimension of the image in pixels.
	 * @param {number} [options.shells=4] - The number of shells to generate (min 1, max 8).
	 * @param {number} [options.segments=Infinity] - The number of segments of equal angle to snap the arcs to.
	 * @param {number} [options.symmetryAxisTilt=null] - If a number, makes the SVG symmetric about the line defined here in polar coordinates (degrees).
	 * @returns {Object} SVG element object containing the identicon.
	 */
	function generateCircular(hash, options){
		var bytes = string2ByteArray(hash);

		var fillColor = "#" + padFront(bytes[bytes.length - 3], 16, 2) +
		                      padFront(bytes[bytes.length - 2], 16, 2) +
		                      padFront(bytes[bytes.length - 1], 16, 2);
		var size = options.size;
		var innerRadius = Math.floor(size / ((options.shells * 2) + 1));
		var centerx = Math.floor(size / 2);
		var centery = Math.floor(size / 2);
		
		var svg = document.createElementNS(svgNS, 'svg');

		svg.setAttribute('width', size);
		svg.setAttribute('height', size);
		svg.setAttribute('xmlns', svgNS);

		// The inner circle always exists, so we create it outside the loop with just a circle element
		var innerCircle = document.createElementNS(svgNS, 'circle');

		innerCircle.setAttribute('cx', centerx);
		innerCircle.setAttribute('cy', centery);
		innerCircle.setAttribute('r', innerRadius + 1);
		innerCircle.setAttribute('fill', fillColor);

		svg.appendChild(innerCircle);

		for(let i = 1; i < options.shells; ++i){
			// Using floorToMultiple snaps the angles for segmenting
			var theta1 = floorToMultiple(360 * (bytes[(i * 2) + 0] / 0xFF), 360 / options.segments);
			var theta2 = floorToMultiple(360 * (bytes[(i * 2) + 1] / 0xFF), 360 / options.segments);

			if(theta2 < theta1){
				let temp = theta1;
				theta1 = theta2;
				theta2 = temp;
			}

			var arc = document.createElementNS(svgNS, 'path');
			arc.setAttribute('d', getArcPath(i, theta1, theta2));
			arc.setAttribute('fill', fillColor);
			svg.appendChild(arc);

			if(options.symmetryAxisTilt !== null){
				let temp = theta1;
				theta1 = (options.symmetryAxisTilt * 2) - theta2;
				theta2 = (options.symmetryAxisTilt * 2) - temp;

				arc = document.createElementNS(svgNS, 'path');
				arc.setAttribute('d', getArcPath(i, theta1, theta2));
				arc.setAttribute('fill', fillColor);
				svg.appendChild(arc);
			}
		}

		return svg;

		/**
		 * Generates the path attribute for an arc given a shell and two angles.
		 * 
		 * @param {number} shell - The shell to draw the arc for (affects radii).
		 * @param {number} theta1 - The starting angle for drawing the arc (0, 360) (degrees).
		 * @param {number} theta2 - The end angle for drawing the arc, theta2 > theta1 (0, 360) (degrees).
		 * @returns {string} Value of the d attribute for the path element.
		 */
		function getArcPath(shell, theta1, theta2){
			var r1 = innerRadius * shell;
			var r2 = innerRadius * (shell + 1) + 1;

			var largeArcFlag = (theta2 - theta1) < 180 ? 0 : 1;

			return `M ${centerx + polar2CartesianX(r2, theta1)} ${centery + polar2CartesianY(r2, theta1)} ` +
				   `A ${r2} ${r2} 0 ${largeArcFlag} 1 ${centerx + polar2CartesianX(r2, theta2)} ${centery + polar2CartesianY(r2, theta2)} ` +
				   `L ${centerx + polar2CartesianX(r1, theta2)} ${centery + polar2CartesianY(r1, theta2)} ` +
				   `A ${r1} ${r1} 0 ${largeArcFlag} 0 ${centerx + polar2CartesianX(r1, theta1)} ${centery + polar2CartesianY(r1, theta1)} ` +
				   'Z';
		}
	}

	/**
	 * Turns an id and a hashing function into a unique polygonal identicon SVG element.
	 * 
	 * @private
	 * @param {string} hash - A string representing a hexadecimal number. Ideally, this is the output of a hash function such as MD5 or SHA-1.
	 * @param {Object} [options] - Settings to change the shape and size of the identicon (not all options have an effect on certain shapes).
	 * @param {number} [options.size=512] - The dimension of the image in pixels.
	 * @param {number} [options.shells=4] - The number of shells to generate (min 1, max 8).
	 * @param {number} [options.edges=5] - The number of edges (i.e. 6 makes a regular hexagon shape).
	 * @returns {Object} SVG element object containing the identicon.
	 */
	function generatePolygonal(hash, options){
		var bytes = string2ByteArray(hash);

		var fillColor = "#" + padFront(bytes[bytes.length - 3], 16, 2) +
		                      padFront(bytes[bytes.length - 2], 16, 2) +
		                      padFront(bytes[bytes.length - 1], 16, 2);
		var size = options.size;
		var innerRadius = Math.floor(size / ((options.shells * 2) + 1));
		var centerx = Math.floor(size / 2);
		var centery = Math.floor(size / 2);

		var svg = document.createElementNS(svgNS, 'svg');

		// Using crispEdges removes seams but also anti-aliasing
		// At the moment, seams are more acceptable than aliasing
		svg.setAttribute('width', size);
		svg.setAttribute('height', size);
		svg.setAttribute('xmlns', svgNS);
		//svg.setAttribute('shape-rendering', 'crispEdges');

		// TODO: Draw "arc" instead of each edge to avoid seams
		// Loop fills pieces for each shell
		for(let i = 0; i < options.shells; ++i){
			for(let j = 0; j < options.edges; ++j){
				if(!i || getBit(((i * options.shells) + j) % bytes.length, bytes)){
					// Angles are used to determine the locations of the vertices
					var theta1 = (360 / options.edges) * j;
					var theta2 = (360 / options.edges) * (j + 1);

					if(theta2 < theta1){
						let temp = theta1;
						theta1 = theta2;
						theta2 = temp;
					}

					var r1 = innerRadius * i;
					var r2 = innerRadius * (i + 1);
					r2 -= (r2 - r1) / 10;

					// See MDN documentation on the SVG path element's d attribute
					var d = `M ${centerx + polar2CartesianX(r2, theta1)} ${centery + polar2CartesianY(r2, theta1)} ` +
					        `L ${centerx + polar2CartesianX(r2, theta2)} ${centery + polar2CartesianY(r2, theta2)} ` +
					        `L ${centerx + polar2CartesianX(r1, theta2)} ${centery + polar2CartesianY(r1, theta2)} ` +
					        `L ${centerx + polar2CartesianX(r1, theta1)} ${centery + polar2CartesianY(r1, theta1)} ` +
					        'Z';

					var edge = document.createElementNS(svgNS, 'path');

					edge.setAttribute('d', d);
					edge.setAttribute('fill', fillColor);

					svg.appendChild(edge);
				}
			}
		}

		return svg;
	}

	/**
	 * Turns a string of hexadecimal characters into an array of byte-sized numbers.
	 * 
	 * @private
	 * @param {string} string - The input to convert.
	 * @returns {number[]} Array whose elements are byte-sized numbers.
	 */
	function string2ByteArray(string){
		var bytes = [];
		for(var i = 0; i < string.length / 2; ++i){
			bytes[i] = parseInt(string.substr(i * 2, 2), 16);
		}
		return bytes;
	}

	/**
	 * Gets the x-coordinate in Cartesian coordinates from polar coordinates.
	 * 
	 * @private
	 * @param {number} r - The distance from the origin.
	 * @param {number} theta - The angle from the reference axis in degrees.
	 * @returns {number}
	 */
	function polar2CartesianX(r, theta){
		var radians = Math.PI * (theta - 90) / 180;
		return r * Math.cos(radians);
	}

	/**
	 * Gets the y-coordinate in Cartesian coordinates from polar coordinates.
	 * 
	 * @private
	 * @param {number} r - The distance from the origin.
	 * @param {number} theta - The angle from the reference axis in degrees.
	 * @returns {number}
	 */
	function polar2CartesianY(r, theta){
		var radians = Math.PI * (theta - 90) / 180;
		return r * Math.sin(radians);
	}

	/**
	 * Reduces a number to a multiple of some other number. Like generalized integer division.
	 * 
	 * @private
	 * @param {number} n - The number to floor.
	 * @param {number} m - The number to floor to a multiple of.
	 * @returns {number} Multiple of m closest to but not greater than n.
	 */
	function floorToMultiple(n, m){
		if(!m){
			return n;
		}
		n /= m;
		n = Math.floor(n);
		return n * m;
	}

	/**
	 * Gets the nth bit from an array of bytes.
	 * 
	 * @private
	 * @param {number} n - The index of the bit (0 is the lowest-order bit, 8 is the first bit of the second byte, etc...).
	 * @param {number[]} bytes - The array of bytes to look through.
	 * @returns {number} 0 or 1.
	 */
	function getBit(n, bytes){
		var byteIndex = Math.floor(n / 8) % bytes.length;
		var bitIndex = 7 - ((n % (8 * bytes.length)) - (byteIndex * 8));

		return (bytes[byteIndex] & (0x01 << bitIndex)) >> bitIndex;
	}

	/**
	 * Turns a number into a string padded on the left with zeroes until it's a specified length.
	 * 
	 * @private
	 * @param {number} n - The number to be padded.
	 * @param {number} base - Convert the number to this base.
	 * @param {number} size - The width of the output.
	 * @returns {string}
	 */
	function padFront(n, base, size){
		var s = n.toString(base);
		while(s.length < size){
			s = '0' + s;
		}
		return s;
	}
}
